<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>StoryPlayer Demo Stories</title>
    <link href="../dist/storyplayer.css" rel="stylesheet" type="text/css">
    <link href="demos.css?foo=6" rel="stylesheet" type="text/css">
    <link href="../node_modules/jsoneditor/dist/jsoneditor.min.css" rel="stylesheet" type="text/css">
    <script src="../node_modules/jsoneditor/dist/jsoneditor.min.js"></script>
</head>

<body>
    <h1>StoryKit Demo Experiences</h1>

    <!-- tab switcher -->
    <div class="tab">
        <button id="choosetab" class="tablinks" onclick="openTab(event, 'chooser')">Select story</button>
        <button id="jsontab" class="tablinks" onclick="openTab(event, 'jsoncontent')">View Data Model JSON</button>
        <button id="rendertab" class="tablinks" onclick="openTab(event, 'renderer')">Render</button>
    </div>

    <!-- Select a story -->
    <div id='chooser' class='tabcontent'>
        <div id='choices' class='selection'></div>
    </div>

    <!-- View rendered content -->
    <div id='renderer' class='tabcontent'>
        <h2 id='story-title' class='story-title'>No story selected</h2>
        <div class='romper-container'>
            <div class='romper-target' id="romper-target">
                <p class='render-placeholder'>Select a demo story and it will be rendered here.</p>
            </div>
        </div>
        <div>
            <!-- restart button -->
            <button id="restart-button" class="restart-button" onclick="restart()" disabled>Restart story</button>
        </div>

        <!-- Allow user to modify variables -->
        <!-- <div id='variable-pane'class='variable-setter active'>
            <h3>Modify variable values here</h3>
            <p>The first Narrative Element is already loaded, so the story will need to be restarted to apply changes.</p>
            <div id='variables-generic'>Load a story to see its variables.</div>
        </div> -->
    </div>

    <!-- Explore story -->
    <div id="explorer">
        <ul id="narrative-path" class="nav-list">
        </ul>
    </div>

    <!-- View/edit json -->
    <div id='jsoncontent' class='jsoncontent tabcontent'>
        <div id='json-view'></div>
        <button id='runjson' onclick="runEditedJson()" disabled>Run</button>
    </div>

    <!-- information for users -->
    <div id='feedback' class='feedback'></div>

    <script src="../dist/storyplayer.js"></script>
    <script>
        window.addEventListener('resize', resizeWindow);

        let romperInstance;
        let loadedStoryJson;

        // ---------------------------------------------------------------------
        // ME: State

        // All narrative elements in a root story
        let allNarrativeElements;
        // All representations in a root story
        let allRepresentations;
        // Map { narrative element ids: marks } storing marks on narrative elements as we traverse.
        let neState;
        // Chronologically ordered array of traversed narrative waypoints
        let narrativePath;
        // current position
        let idOfCurrentNarrativeEl;
        let idOfCurrentRepresentation;
        let localPlayheadTime;
        let globalPlayheadTime;

        // ---------------------------------------------------------------------

        function resizeWindow() {
        }

        // load demo stories
        const stories = [
            'demo1.json',
            'demo2.json',
            'demo3.json',
            'demo2b.json',
            'demo4.json',
            "demo-form.json",
        ];

        const promises = []
        stories.forEach(storyFilename => promises.push(fetchFile(storyFilename)));
        Promise.all(promises).then((texts) => {
            const divs = [];
            texts.forEach((text, i) => {
                const storyjson = JSON.parse(text);
                const name = storyjson.stories[0].name;
                const description = storyjson.stories[0].description;
                divs.push(addStoryOption(stories[i], name, description));
            });
            divs.sort(function (a, b) {
                return (a.id < b.id) ? -1 : (a.id > b.id) ? 1 : 0;
            }).forEach(function (elem) {
                document.getElementById('choices').appendChild(elem);
            });
        }).catch((rejection) => {
            console.warn('Could not load built-in demo file');
        });

        // return promise to fetch
        function fetchFile(filename) {
            return fetch(filename)
                .then((response) => {
                    if (response.ok) {
                        return Promise.resolve(response.text());
                    }
                    return Promise.reject(response);
                })
                .catch((rejection) => {
                    console.warn(`could not fetch story content for ${filename}: ${rejection.status} ${rejection.statusText}`);
                    return Promise.reject(rejection);
                });
        }

        // render a story for user selection
        function addStoryOption(filename, storyName, storyDescription) {
            const storyDiv = document.createElement('div');
            let id = storyName.replace(/ /g, '_');
            storyDiv.id = id.replace(/[^0-9a-zA-Z_]*/g, '_');
            const title = document.createElement('h3');
            title.textContent = storyName;
            const desc = document.createElement('p');
            desc.textContent = storyDescription;
            const selectButton = document.createElement('button');
            selectButton.onclick = () => loadStory(filename);
            selectButton.textContent = "Select";

            storyDiv.appendChild(title);
            storyDiv.appendChild(desc);
            storyDiv.appendChild(selectButton);
            return storyDiv;
        }

        // get a GET query parameter
        function getParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        // load a story from file whose path supplied in query
        const getFilename = getParameterByName('storyjson');
        if (getFilename) {
            fetchFile(getFilename).then((text) => {
                const storyjson = JSON.parse(text);
                const name = storyjson.stories[0].name;
                const description = storyjson.stories[0].description;
                document.getElementById('choices').appendChild(addStoryOption(getFilename, name, description));
            })
                .catch((rejection) => {
                    console.warn(`could not load GET story content`);
                });
            loadStory(getFilename);
            document.getElementById('renderer').classList.add('active');
            document.getElementById('rendertab').classList.add('active');

        } else {
            document.getElementById('chooser').classList.add('active');
            document.getElementById('choosetab').classList.add('active');
        }

        // display a message to the user
        function showMessage(messageText, error = false) {
            const messageDiv = document.getElementById('feedback');
            messageDiv.textContent = messageText;
            if (error) {
                messageDiv.classList.add('warning');
            } else {
                messageDiv.classList.remove('warning');
            }
        }

        // jsoneditor
        const options = {
            mode: 'tree',
        };
        const jsonEditor = new JSONEditor(document.getElementById('json-view'), options);

        // handle changing tabs
        function openTab(evt, demoName) {

            // Get all elements with class="tabcontent" and hide them
            var tabcontent = document.getElementsByClassName("tabcontent");
            for (var i = 0; i < tabcontent.length; i++) {
                tabcontent[i].classList.remove('active');
            }

            // Get all elements with class="tablinks" and remove the class "active"
            var tablinks = document.getElementsByClassName("tablinks");
            for (var i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }

            // Show the current tab, and add an "active" class to the button that opened the tab
            document.getElementById(demoName).classList.add("active");
            evt.currentTarget.className += " active";

            if (evt.currentTarget.id === 'rendertab') {
                resizeWindow();
            }
        }

        // run edited json
        function runEditedJson() {
            const storyJson = jsonEditor.get();
            try {
                run(storyJson);
                showMessage('Story loaded - view the renderer.');
            } catch (e) {
                showMessage('Could not run your json - see the console!');
                console.log(e);
            }
        }

        // ---------------------------------------------------------------------
        // ME: Narrative progression utils

        /**
         * Check if an object implements a function with the given key.
         * adapted from: https://stackoverflow.com/questions/18884249/checking-whether-something-is-iterable
         */
        function implements(methodKey, obj) {
            if (obj == null) {
                return false;
            }
            return typeof obj[methodKey] === "function";
        }

        /**
         * Check if an object implements the iterator protocol.
         */
        function implementsIterator(obj) {
            return implements(Symbol.iterator, obj);
        }

        /**
         * Check if an object matches the lodash definition of an array-like.
         */
        function isArrayLike(obj) {
            if (obj == null || typeof obj === "function") {
                return false;
            }
            // false if .length is not a safe integer 0 <= l <= Number.MAX_SAFE_INTEGER
            let l = obj.length;
            if (l == null || !Number.isSafeInteger(l) || l < 0) {
                return false;
            }
            return true;
        }

        /**
         * Find last index matching the predicate in any array-like object. Lodash definition of array-like.
         * adapted from: https://stackoverflow.com/questions/40929260/find-last-index-of-element-inside-array-by-certain-condition
         */
        function findLastIndex(arraylike, predicate) {
            let l = arraylike.length - 1;
            while (l >= 0) {
                if (predicate(arraylike[l], l, arraylike)) {
                    return l;
                }
                l = l - 1;
            }
            return -1;
        }

        /**
         * Find first index matching the predicate in any array-like object. Lodash definition of array-like.
         */
        function findFirstIndex(arraylike, predicate) {
            let i = 0;
            while (i <= arraylike.length - 1) {
                if (predicate(arraylike[i], i, arraylike)) {
                    return i;
                }
                i = i + 1;
            }
            return -1;
        }

        /**
         * Find the first element matching the predicate in any array-like object. Lodash definition of array-like.
         */
        function findFirst(arraylike, predicate) {
            let loc = findFirstIndex(arraylike, predicate);
            if (loc === -1) {
                return undefined;
            }
            return arraylike[loc];
        }

        /**
         * Get id of all narrative elements in a story.
         * Does not handle substories (nested).
         * Does not handle live stories (build-as-you-go).
         */
        function allNarrativeElementIdsInStory(experience, idOfRootStory) {
            const stories = experience?.stories;
            if (!isArrayLike(stories) || !implementsIterator(stories)) {
                console.error("Invalid experience! .stories is not an array-like iterable.");
                return [];
            }

            if (stories.length == 0) {
                return [];
            }

            const rootStory = findFirst(stories, someStory => someStory.id == idOfRootStory);
            if (!isArrayLike(rootStory.narrative_element_ids) || !implementsIterator(rootStory.narrative_element_ids)) {
                console.error("Invalid story! .narrative_element_ids is not an array-like iterable.");
                return [];
            }

            return rootStory.narrative_element_ids;
        }

        function getNarrativeElementById(experience, idOfNarrativeElement) {
            const allNarrativeElements = experience?.narrative_elements;
            if (!isArrayLike(allNarrativeElements) || !implementsIterator(allNarrativeElements)) {
                console.error("Invalid experience! .narrative_elements is not an array-like iterable.");
                return null;
            }

            if (!implements("find", allNarrativeElements)) {
                console.error(".narrative_elements does not implement .find().");
                return null;
            }

            return allNarrativeElements.find(someNE => someNE.id == idOfNarrativeElement);
        }

        /**
         * Get narrative elements in an experience from a list of ids.
         * Does not care about narrative element traversability.
         * Does not care about narrative element reachability.
         */
        function getNarrativeElements(experience, ...idsOfNarrativeElements) {
            const allNarrativeElements = experience?.narrative_elements;
            if (!isArrayLike(allNarrativeElements) || !implementsIterator(allNarrativeElements)) {
                console.error("Invalid experience! .narrative_elements is not an array-like iterable.");
                return [];
            }

            if (!implements("filter", allNarrativeElements)) {
                console.error(".narrative_elements does not implement .filter().");
                return [];
            }

            return allNarrativeElements.filter((someNE) => {
                return idsOfNarrativeElements.includes(someNE.id);
            });
        }

        function getRepresentationById(experience, repId) {
            const allRepresentations = experience?.representations;
            if (!isArrayLike(allRepresentations) || !implementsIterator(allRepresentations)) {
                console.error("Invalid experience! .representations is not an array-like iterable.");
                return null;
            }

            return findFirst(allRepresentations, function (rep) {
                return rep.id == repId;
            });
        }

        function getRepresentationForNarrativeElementById(experience, neId) {
            let ne = getNarrativeElementById(experience, neId);
            if (ne == null) {
                return null;
            }

            const allRepresentationCollections = experience?.representation_collections;
            if (!isArrayLike(allRepresentationCollections) || !implementsIterator(allRepresentationCollections)) {
                console.error("Invalid experience! .representation_collections is not an array-like iterable.");
                return null;
            }

            let repCol = findFirst(allRepresentationCollections, function (repCol) {
                return repCol.id == ne.body.representation_collection_target_id;
            });

            if (!isArrayLike(repCol.representations) || !implementsIterator(repCol.representations)) {
                console.error("Invalid representation collection! .representations is not an array-like iterable.");
                return null;
            }

            if (repCol.representations.length == 0) {
                return null;
            }

            // Assume only one representation
            let repId = repCol.representations[0]?.representation_id
            return getRepresentationById(experience, repId);
        }

        function allRepresentationsInStory(experience, idOfRootStory) {
            const stories = experience?.stories;
            if (!isArrayLike(stories) || !implementsIterator(stories)) {
                console.error("Invalid experience! .stories is not an array-like iterable.");
                return [];
            }

            if (stories.length == 0) {
                return [];
            }

            const rootStory = findFirst(stories, someStory => someStory.id == idOfRootStory);
            if (!isArrayLike(rootStory.representations) || !implementsIterator(rootStory.representations)) {
                console.error("Invalid story! .representations is not an array-like iterable.");
                return [];
            }

            return rootStory.representations;
        }

        function getAssetCollectionById(experience, assetId) {
            const assetCollections = experience?.asset_collections;
            if (!isArrayLike(assetCollections) || !implementsIterator(assetCollections)) {
                console.error("Invalid experience! .asset_collections is not an array-like iterable.");
                return null;
            }

            if (assetCollections.length == 0) {
                return null;
            }

            return findFirst(assetCollections, someAC => someAC.id == assetId);
        }

        /**
         * Create a step along a narrative path.
         */
        function newStep(fromNEId, toNEId) {
            return { from: fromNEId, to: toNEId }
        }

        /**
         * Create a waypoint object along a narrative path.
         */
        function newWaypoint(experience, romper, fromNEId, toNEId) {
            let newWaypoint = {
                pathOptions: {},
                pathChoice: toNEId
            };
            let idOfPathOptions = [toNEId];

            // is step to a beginning
            let beginnings = experience.stories[0].beginnings;
            if (beginnings.length > 1 && beginnings.some(beginning => beginning.narrative_element_id == toNEId)) {
                idOfPathOptions.push(...experience.stories[0].beginnings.map(beginning => beginning.narrative_element_id));
            }

            // is step from a fork?
            let fromNE = experience.narrative_elements.find(ne => ne.id == fromNEId)
            if (fromNE && fromNE.links.length > 1) {
                idOfPathOptions.push(...fromNE.links.map(link => link.target_narrative_element_id));
            };

            // fetch NEs
            idOfPathOptions.forEach(neId => {
                if (newWaypoint.pathOptions[neId] == null) { // handle repeats
                    let ne = romper._getNarrativeElement(neId);
                    newWaypoint.pathOptions[neId] = {
                        name: ne.name,
                        narrativeEl: ne,
                    };
                }
            });

            // fetch Reps
            idOfPathOptions.forEach(neId => {
                if (newWaypoint.pathOptions[neId].representation == null) {
                    // fetch rep
                    let rep = getRepresentationForNarrativeElementById(experience, neId);
                    newWaypoint.pathOptions[neId].representation = rep
                    // fetch video
                    let assetId = rep.asset_collections.foreground_id;
                    let assetCol = getAssetCollectionById(experience, assetId)
                    newWaypoint.pathOptions[neId].assetCol = assetCol;
                }
            });

            return newWaypoint;
        }

        /**
         * Check a waypoint contains some narrative element (by id).
         */
        function containsNarrativeElement(someWaypoint, neId) {
            return someWaypoint.pathOptions[neId] ?? false
        }

        function moveToWaypoint(someNarrativePath, experience, romper, fromNEId, toNEId) {
            let pathIndex = findLastIndex(
                someNarrativePath,
                someWaypoint => containsNarrativeElement(someWaypoint, toNEId)
            );

            // If next direction is a new path:
            // Append it to the end of the path.
            if (pathIndex == -1) {
                let newWp = newWaypoint(experience, romper, fromNEId, toNEId);
                someNarrativePath.push(newWp);
                return;
            }

            // If next direction is a branch-off
            // Roll back to that point in the path, and switch path choice.
            if (someNarrativePath[pathIndex].pathChoice !== toNEId) {
                // TODO: See if branch-off is a fold-back path
                someNarrativePath.splice(pathIndex + 1, someNarrativePath.length - pathIndex - 1);
                someNarrativePath[pathIndex].pathChoice = toNEId;
                return;
            }

            // path choice is not new
            return;
        }

        function reduceNarrativeState(state, action) {
            switch (action.type) {
                case "VISIT":
                    const prevState = state[action.id] ?? {};
                    state[action.id] = {
                        ...prevState,
                        visited: true,
                    };
                    return;
                default:
                    return;
            }
        }

        function addDirectionElement(romper, someDirection) {
            const directionDiv = document.createElement("div");
            directionDiv.id = someDirection.name.replace(/ /g, '_');
            directionDiv.classList.add("Direction");

            const directionName = document.createElement("span");
            directionName.textContent = someDirection.name;
            directionDiv.appendChild(directionName);

            const directionMeta = document.createElement("span");
            directionMeta.textContent = ` (${someDirection.assetCol.tags.duration} sec)`
            directionDiv.appendChild(directionMeta);

            directionDiv.addEventListener("click", function () {
                romper._jumpToNarrativeElement(someDirection.narrativeEl.id);
            });

            return directionDiv;
        }

        function addWaypointElement(romper, someWaypoint, neState) {
            const waypointDiv = document.createElement("div");
            waypointDiv.id = someWaypoint.pathChoice;
            waypointDiv.classList.add("Waypoint");

            const chosenDirection = document.createElement("div");
            waypointDiv.appendChild(chosenDirection);

            let otherDirections = null;

            for (const [idOfNarrativeElement, someDirection] of Object.entries(someWaypoint.pathOptions)) {
                const directionEl = addDirectionElement(romper, someDirection);

                if (neState[idOfNarrativeElement]?.visited) {
                    directionEl.classList.add("visited");
                }

                // if is chosen direction
                if (idOfNarrativeElement == someWaypoint.pathChoice) {
                    directionEl.classList.add("path-choice");
                    chosenDirection.appendChild(directionEl);
                    continue;
                }

                // if not chosen direction:

                // if first optional direction
                if (otherDirections == null) {
                    otherDirections = document.createElement("ul");
                    waypointDiv.appendChild(otherDirections);
                }

                directionEl.classList.add("path-option");
                const liEl = document.createElement("li");
                liEl.appendChild(directionEl);
                otherDirections.appendChild(liEl);
            }

            return waypointDiv;
        }

        // ---------------------------------------------------------------------

        // run some json through romper
        function run(config) {
            document.getElementById('romper-target').innerHTML = '';
            loadedStoryJson = config;
            document.getElementById('runjson').removeAttribute('disabled');
            document.getElementById('runjson').classList.add('active');
            document.getElementById('restart-button').classList.add('active');
            document.getElementById('restart-button').removeAttribute('disabled');
            document.getElementById('story-title').textContent = config.stories[0].name;
            jsonEditor.set(config);

            // -----------------------------------------------------------------
            // ME: Init narrative path

            let idsOfNarrativeElementsInStory = allNarrativeElementIdsInStory(config, config.stories[0].id);
            allNarrativeElements = getNarrativeElements(config, ...idsOfNarrativeElementsInStory);
            allRepresentations = allRepresentationsInStory(config, config.stories[0].id)
            narrativePath = [];
            neState = {};
            let playheadPoller;
            localPlayheadTime = 0.0;
            globalPlayheadTime = 0.0;
            const positionEl = document.createElement("div");
            const updatePosition = (secsSoFar) => {
                timeSoFar = new Date(secsSoFar * 1000).toISOString().substr(11, 8)
                positionEl.textContent = `Current time: ${timeSoFar}`;
            }

            // -----------------------------------------------------------------

            romperInstance = window.Storyplayer.init({
                target: document.getElementById('romper-target'),
                staticImageBaseUrl: '/src/assets/images/',

                // -------------------------------------------------------------
                // ME: Narrative progression analytics

                analyticsLogger: dataObj => {
                    console.log('ANALYTICS:', dataObj);
                    console.error("pika", narrativePath, neState);
                    if (dataObj.name == "NARRATIVE_ELEMENT_CHANGE") {
                        moveToWaypoint(narrativePath, config, romperInstance, dataObj.from, dataObj.to);
                        reduceNarrativeState(neState, { type: "VISIT", id: dataObj.to });
                        idOfCurrentNarrativeEl = dataObj.to;
                        idOfCurrentRepresentation = getRepresentationForNarrativeElementById(dataObj.to)?.id;
                    }
                    if (dataObj.type == "RENDERER_ACTION") {
                        if (playheadPoller) {
                            clearInterval(playheadPoller);
                            playheadPoller = undefined;
                        }
                        playheadPoller = setInterval(function getPlayheadTime() {
                            let { currentTime, duration } = romperInstance
                                .getCurrentRenderer()
                                .getCurrentTime();
                            if (!Number.isFinite(currentTime)) {
                                return;
                            }
                            currentTime = Number.parseInt(currentTime, 10); // assume seconds
                            if (localPlayheadTime == currentTime) {
                                return;
                            }
                            localPlayheadTime = currentTime;
                            duration = Number.parseInt(duration, 10);
                            let indexOfCorrentPosition = findLastIndex(narrativePath, wp => {
                                return wp.pathChoice == idOfCurrentNarrativeEl;
                            });
                            let pathToCurrentPosition = narrativePath.slice(0, indexOfCorrentPosition);
                            let durationSoFar = 0.0;
                            durationSoFar = pathToCurrentPosition.reduce(
                                function (sumSoFar, someWaypoint) {
                                    wpDuration = someWaypoint.pathOptions[someWaypoint.pathChoice]?.assetCol.tags.duration ?? 0;
                                    return sumSoFar + wpDuration;
                                }, durationSoFar)
                            globalPlayheadTime = durationSoFar + localPlayheadTime;
                            updatePosition(globalPlayheadTime);
                        }, 50);
                    }

                    // DRAWING NARRATIVE PATH
                    const narrativePathEl = document.getElementById("narrative-path");

                    // convert to html elements
                    let pathItems = narrativePath.map(waypoint => {
                        return addWaypointElement(romperInstance, waypoint, neState);
                    });

                    // draw current position
                    let activeWp = pathItems.find(waypoint => {
                        return waypoint.id == idOfCurrentNarrativeEl;
                    });
                    activeWp?.classList.add("active");
                    activeWp.appendChild(positionEl);

                    // convert to list
                    pathItems = pathItems.map(waypointEl => {
                        const liEl = document.createElement("li");
                        liEl.appendChild(waypointEl);
                        return liEl;
                    });

                    // TODO: Profile and optimise
                    narrativePathEl.replaceChildren(...pathItems);

                    console.error("chu", narrativePath, neState);
                },

                // ---------------------------------------------------------------------

                storyFetcher: id => Promise.resolve().then(
                    () => config.stories.filter(storyObject => storyObject.id === id)[0]
                ),
                mediaFetcher: uri => Promise.resolve(uri).then(resolvedUri => resolvedUri ? resolvedUri : Promise.reject('cannot resolve uri')),
                representationCollectionFetcher: id => Promise.resolve(
                    config.representation_collections
                        .filter(presentationObject => presentationObject.id === id)[0]
                ).then(presentationObject => presentationObject ? presentationObject : Promise.reject('no such presentation object: ' + id)),
                assetCollectionFetcher: id => Promise.resolve(
                    config.asset_collections
                        .filter(assetCollectionObject => assetCollectionObject.id === id)[0]
                ).then(assetCollectionObject => assetCollectionObject ? assetCollectionObject : Promise.reject('no such asset collection: ' + id)),
                representationFetcher: id => Promise.resolve(
                    config.representations
                        .filter(representationObject => representationObject.id === id)[0]
                ).then(representationObject => representationObject ? representationObject : Promise.reject('no such representation: ' + id)),
                narrativeElementFetcher: id => Promise.resolve(
                    config.narrative_elements
                        .filter(narrativeElementObject => narrativeElementObject.id === id)[0]
                ).then(narrativeElementObject => narrativeElementObject ? narrativeElementObject : Promise.reject('no such narrative element: ' + id)),
            });

            // -------------------------------------------------------------
            // ME: Narrative position

            updatePosition(globalPlayheadTime);

            // -------------------------------------------------------------


            romperInstance.start(config.stories[0].id, getVariablesState());
            // romperInstance.on(window.Romper.REASONER_EVENTS.ROMPER_STORY_STARTED, () => {
            //     addVariableControls(config.stories[0].id);
            // });
        }

        function restart() {
            showMessage('Story restarted');
            romperInstance.restart(loadedStoryJson.stories[0].id, getVariablesState());
            resizeWindow();
        }

        function addMeta(storyId) {
            const experienceIdMeta = document.querySelector('meta[name="experienceId"]');
            if (!experienceIdMeta) {
                const meta = document.createElement('meta');
                meta.name = 'experienceId';
                meta.content = storyId;
                document.getElementsByTagName('head')[0].appendChild(meta);
            } else {
                experienceIdMeta.setAttribute("content", storyId);
            }
        }

        // fetch a story, load and run it
        function loadStory(filepath) {
            showMessage(`Loading ${filepath}`);
            document.getElementById('romper-target').innerHTML = '';
            fetch(filepath)
                .then((response) => {
                    if (response.ok) {
                        return Promise.resolve(response.text());
                    }
                    return Promise.reject(response);
                })
                .then((text) => {
                    showMessage('Story loaded');
                    const storyJson = JSON.parse(text);
                    addMeta(storyJson.stories[0].id);
                    run(storyJson);
                    if (document.getElementById('rendertab').classList.contains('active')) {
                        resizeWindow();
                    }
                })
                .catch((rejection) => {
                    showMessage(rejection);
                    showMessage(`could not load story content: ${rejection.status} ${rejection.statusText}`, true);
                });
        };

        function addVariableControls() {
            const varPanel = document.getElementById('variables-generic');
            romperInstance.getVariableState()
                .then((variableDeclaration) => {
                    if (variableDeclaration === undefined || variableDeclaration === {}) {
                        varPanel.innerHTML = 'There are no variables in this story';
                        return;
                    }

                    varPanel.innerHTML = '';
                    Object.keys(variableDeclaration).forEach((varName) => {
                        addVariableSetter(varName, variableDeclaration[varName]);
                    });
                });
        }

        // render a panel enabling the user to modify the value of a variable
        function addVariableSetter(varName, variableDecl) {
            const varType = variableDecl.variable_type;
            const varDesc = variableDecl.description;
            const parEl = document.createElement('p');
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('slider-choice');
            nameSpan.textContent = varName;

            const descSpan = document.createElement('span');
            descSpan.classList.add('variable-description');
            descSpan.textContent = `(${varDesc})`;

            const sliderSpan = document.createElement('span');
            const label = document.createElement('label');
            label.classList.add('switch');

            let varInput;
            if (varType === 'boolean') {
                varInput = getBooleanVariableSwitch(varName, variableDecl);
            } else if (varType === 'integer') {
                varInput = getIntegerVariableSetter(varName, variableDecl);
            } else if (varType === 'number') {
                varInput = getIntegerVariableSetter(varName, variableDecl);
            } else if (varType === 'string') {
                varInput = getStringVariableSetter(varName, variableDecl);
            } else if (varType === 'list') {
                varInput = getListVariableSetter(varName, variableDecl);
            } else {
                console.warn(`Cannot adjust variable of type ${varType}`);
                return;
            }
            varInput.id = varName;
            varInput.classList.add('variable-input');

            label.appendChild(varInput);
            label.appendChild(sliderSpan);
            parEl.appendChild(label);
            parEl.appendChild(nameSpan);
            parEl.appendChild(descSpan);

            const varPanel = document.getElementById('variables-generic');
            varPanel.appendChild(parEl);
        }

        // an input for changing integer variables
        function getIntegerVariableSetter(varName, variableDecl) {
            const varInput = document.createElement('input');
            varInput.type = 'number';

            if (variableDecl.default_value) { varInput.value = variableDecl.default_value; }
            varInput.onchange = () => romperInstance.setVariableValue(varName, varInput.value);

            return varInput;
        }

        // an input for changing string variables
        function getStringVariableSetter(varName, variableDecl) {
            const varInput = document.createElement('input');
            varInput.type = 'text';

            if (variableDecl.default_value) { varInput.value = variableDecl.default_value; }
            varInput.onchange = () => romperInstance.setVariableValue(varName, varInput.value);

            return varInput;
        }

        // an input for changing enumerated string variables
        function getListVariableSetter(varName, variableDecl) {
            const options = variableDecl.values;
            const varInput = document.createElement('select');
            options.forEach((optionValue) => {
                const optionElement = document.createElement('option');
                optionElement.setAttribute('value', optionValue);
                optionElement.textContent = optionValue;
                varInput.appendChild(optionElement);
            });

            if (variableDecl.default_value) { varInput.value = variableDecl.default_value; }
            varInput.onchange = () => romperInstance.setVariableValue(varName, varInput.value);

            return varInput;
        }

        // an input for changing boolean variables
        function getBooleanVariableSwitch(varName, variableDecl) {
            const varInput = document.createElement('input');
            varInput.type = 'checkbox';

            if (variableDecl.default_value) { varInput.setAttribute('checked', true); }
            varInput.onchange = () => romperInstance.setVariableValue(varName, varInput.checked);

            return varInput;
        }

        // get a key->value object for each variable name->value
        function getVariablesState() {
            const varInputs = document.getElementsByClassName('variable-input');
            const variableState = {};
            for (var i = 0; i < varInputs.length; i++) {
                const varInputEl = varInputs[i];
                if (varInputEl.getAttribute('type') === 'checkbox') {
                    variableState[varInputEl.id] = varInputEl.checked;
                } else if (varInputEl.getAttribute('type') === 'number') {
                    variableState[varInputEl.id] = parseInt(varInputEl.value, 10);
                } else {
                    variableState[varInputEl.id] = varInputEl.value;
                }
            }
            return variableState;
        }

    </script>
</body>

</html>